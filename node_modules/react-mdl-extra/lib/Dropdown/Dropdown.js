'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _CSSPropertyOperations = require('react-dom/lib/CSSPropertyOperations');

var _reactDom = require('react-dom');

var _reactPortal = require('react-portal');

var _reactPortal2 = _interopRequireDefault(_reactPortal);

var _tether = require('tether');

var _tether2 = _interopRequireDefault(_tether);

require('./Dropdown.css');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var POS = {
  t: 'top',
  b: 'bottom',
  l: 'left',
  r: 'right',
  m: 'middle',
  c: 'center'
};

var Dropdown = function (_Component) {
  _inherits(Dropdown, _Component);

  function Dropdown(props) {
    _classCallCheck(this, Dropdown);

    var _this = _possibleConstructorReturn(this, (Dropdown.__proto__ || Object.getPrototypeOf(Dropdown)).call(this, props));

    _this.tether = null;
    _this.onOpen = _this.onOpen.bind(_this);
    _this.beforeClose = _this.beforeClose.bind(_this);
    return _this;
  }

  _createClass(Dropdown, [{
    key: 'applyStyles',
    value: function applyStyles(node, styles) {
      (0, _CSSPropertyOperations.setValueForStyles)(node, styles, this._reactInternalInstance);
    }
  }, {
    key: 'onOpen',
    value: function onOpen(portalNode) {
      var _props = this.props,
          align = _props.align,
          offset = _props.offset,
          useTargetWidth = _props.useTargetWidth,
          useTargetMinHeight = _props.useTargetMinHeight,
          pad = _props.viewportPadding;

      // append class name

      portalNode.classList.add('mdl-dropdown');

      // window is our boundary
      var _window = window,
          innerWidth = _window.innerWidth,
          innerHeight = _window.innerHeight;

      // get target node

      var targetNode = this.props.targetNode || (0, _reactDom.findDOMNode)(this);

      // get bounding rects
      var portal = portalNode.getBoundingClientRect();
      var target = targetNode.getBoundingClientRect();

      // parse position

      var _align$split$map$filt = align.split('').map(function (a) {
        return a && POS[a];
      }).filter(function (a) {
        return a;
      }),
          _align$split$map$filt2 = _slicedToArray(_align$split$map$filt, 4),
          ay = _align$split$map$filt2[0],
          ax = _align$split$map$filt2[1],
          ty = _align$split$map$filt2[2],
          tx = _align$split$map$filt2[3];

      // parse offset


      var _offset$split$map = offset.split(' ').map(function (o) {
        return parseInt(o);
      }),
          _offset$split$map2 = _slicedToArray(_offset$split$map, 2),
          oy = _offset$split$map2[0],
          ox = _offset$split$map2[1];

      // calculate space above and below target


      var spaceAbove = void 0,
          spaceBelow = void 0;
      if (ty === 'top') {
        if (ay === 'top') {
          spaceAbove = target.bottom - pad + oy;
          spaceBelow = innerHeight - target.top - pad + oy;
        } else if (ay === 'bottom') {
          spaceAbove = target.top - pad + oy;
          spaceBelow = innerHeight - target.bottom - pad + oy;
        }
      } else if (ty === 'bottom') {
        if (ay === 'top') {
          spaceAbove = target.top - pad + oy;
          spaceBelow = innerHeight - target.bottom - pad + oy;
        } else if (ay === 'bottom') {
          spaceAbove = target.bottom - pad + oy;
          spaceBelow = innerHeight - target.bottom - pad + oy;
        }
      } else if (ty === 'middle') {
        if (ay === 'top' || ay === 'bottom') {
          spaceAbove = target.top + target.height / 2 - pad + oy;
          spaceBelow = innerHeight - target.bottom + target.height / 2 - pad + oy;
        } else if (ay === 'middle') {
          spaceAbove = innerHeight - pad * 2;
          spaceBelow = innerHeight - pad * 2;
        }
      }

      // flip y if neccessary
      if (ay === 'top' && portal.height > spaceBelow && spaceAbove > spaceBelow) {
        // flip up
        ay = 'bottom';
        if (ty === 'top') {
          ty = 'bottom';
        } else if (ty === 'bottom') {
          ty = 'top';
        }
      } else if (ay === 'bottom' && portal.height > spaceAbove && spaceBelow > spaceAbove) {
        // flip down
        ay = 'top';
        if (ty === 'top') {
          ty = 'bottom';
        } else if (ty === 'bottom') {
          ty = 'top';
        }
      }

      // flip x if neccessary
      if (ax === 'left') {
        // flip left
        if (tx === 'left' && target.left + portal.width + pad + ox > innerWidth) {
          tx = 'right';
          ax = 'right';
        } else if (tx === 'right' && target.right + portal.width + pad + ox > innerWidth) {
          tx = 'left';
          ax = 'right';
        }
      } else if (ax === 'right') {
        // flip left
        if (tx === 'left' && target.left - portal.width < 0) {
          tx = 'right';
          ax = 'left';
        } else if (tx === 'right' && target.right - portal.width < 0) {
          tx = 'left';
          ax = 'left';
        }
      }

      // apply max height
      var maxHeight = Math.max(spaceAbove, spaceBelow);
      this.applyStyles(portalNode, { maxHeight: maxHeight + 'px' });

      // use target width
      if (useTargetWidth) {
        this.applyStyles(portalNode, { width: target.width + 'px' });
      }

      // use target height as min-height
      if (useTargetMinHeight) {
        this.applyStyles(portalNode, { minHeight: target.height + 'px' });
      }

      // tether
      this.tether = new _tether2.default({
        element: portalNode,
        target: targetNode,
        attachment: ay + ' ' + ax,
        targetAttachment: ty + ' ' + tx,
        offset: oy + ' ' + ox,
        constraints: [{
          to: 'window',
          pin: true
        }]
      });

      // fade in
      this.applyStyles(portalNode, { opacity: 1 });

      // force reposition
      if (portal.height > maxHeight) {
        this.tether.position();
      }
    }
  }, {
    key: 'beforeClose',
    value: function beforeClose(portalNode, remove) {
      var _this2 = this;

      if (this.tether) {
        this.tether.destroy();
      }
      this.timeout = setTimeout(function () {
        _this2.timeout = null;
        remove();
      });
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (this.timeout) {
        clearTimeout(this.timeout);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _props2 = this.props,
          children = _props2.children,
          closeOnEsc = _props2.closeOnEsc,
          closeOnOutsideClick = _props2.closeOnOutsideClick,
          target = _props2.target;

      return _react2.default.createElement(
        _reactPortal2.default,
        {
          closeOnEsc: closeOnEsc,
          closeOnOutsideClick: closeOnOutsideClick,
          openByClickOn: target,
          onOpen: this.onOpen,
          beforeClose: this.beforeClose
        },
        children
      );
    }
  }]);

  return Dropdown;
}(_react.Component);

Dropdown.propTypes = {
  align: function align(props, propName, componentName) {
    if (!/[btm][lrc]\ [btm][lrc]/.test(props[propName])) {
      return new Error('Invalid prop ' + propName + ' (' + props[propName] + ') supplied to ' + componentName + '. Validation failed.');
    }
  },
  children: _react.PropTypes.any.isRequired,
  closeOnEsc: _react.PropTypes.bool,
  closeOnOutsideClick: _react.PropTypes.bool,
  offset: _react.PropTypes.string,
  target: _react.PropTypes.element.isRequired,
  targetNode: _react.PropTypes.any,
  useTargetWidth: _react.PropTypes.bool,
  useTargetMinHeight: _react.PropTypes.bool,
  viewportPadding: _react.PropTypes.number
};
Dropdown.defaultProps = {
  align: 'tl tl',
  closeOnEsc: true,
  closeOnOutsideClick: true,
  offset: '0 0',
  viewportPadding: 10
};
exports.default = Dropdown;